from naeural_core.business.default.web_app.fast_api_web_app import FastApiWebAppPlugin as BasePlugin
from .pentest_job_helper import PentestJobHelper  # Import PentestJob from separate module

__VER__ = '0.3.1'  # updated version

_CONFIG = {
  **BasePlugin.CONFIG,
  
  'PORT': None,
  
  "CHECK_JOBS_EACH" : 5,
  
  "WARMUP_DELAY" : 20,
  
  
  'VALIDATION_RULES': {
    **BasePlugin.CONFIG['VALIDATION_RULES'],  
  },
}

class PentesterApi01Plugin(BasePlugin):
  """
  RedMesh API - a pentesting meta-plugin for receiving pentesting targets and performing operations.
  Supports asynchronous job execution and performs distributed red-team attacks based on 
  decentralized workers orchestrated using CStore.
  """
  CONFIG = _CONFIG


  def on_init(self):
    super(PentesterApi01Plugin, self).on_init()
    self.__features = self._get_all_features()
    # Track active and completed jobs by target
    self.scan_jobs = {}       # target -> PentestJob instance
    self.completed_jobs = {}  # target -> final report dict
    self.__last_checked_jobs = 0
    self.__warmupstart = self.time()
    self.__warmup_done = False
    current_epoch = self.netmon.epoch_manager.get_current_epoch()
    self.P("Started {} plugin in epoch {}.".format(
      self.__class__.__name__, current_epoch, 
    ))
    return
  
  def P(self, s, *args, **kwargs):
    s = "[REDMESH] " + s
    return super(PentesterApi01Plugin, self).P(s, *args, **kwargs)
  
  
  def __post_init(self):
    all_network_jobs = self.chainstore_hgetall(hkey=self.cfg_instance_id)
    self.P("Warmup complete. Current jobs for {}:\n{}".format(
      self.cfg_instance_id, 
      self.json_dumps(all_network_jobs, indent=2)
    ))
    self.__warmup_done = True
    return



  def _get_all_features(self, categs=False):
    features = {} if categs else []
    PREFIXES = ["_service_info_", "_web_test_"]
    mock_engine = PentestJobHelper(
      owner=self, target='[GET-INFO-NO-TEST]', logger=self.P, worker_target_ports=[1]
    )
    for prefix in PREFIXES:
      methods = [method for method in dir(mock_engine) if method.startswith(prefix)]
      if categs:
        features[prefix[1:-1]] = methods
      else:
        features.extend(methods)
    return features

  @BasePlugin.endpoint
  def list_features(self):
    result = {"features": self._get_all_features(categs=True)}
    return result


  @BasePlugin.endpoint
  def launch_test(self, target : str):
    """
    Endpoint to start a pentest on the specified target.
    Announce job to network via CStore and return current jobs.            
    """
    # INFO: This method only announces the job to the network. It does not 
    #       execute the job itself - that part is handled by PentestJob
    #       executed after periodical check from plugin process.
    self.P(f"Launching pentest on target {target}")
    self.P(f"Announcing pentest to workers (instance_id {self.cfg_instance_id})...")
    job_specs = {
      "target": target,
      "workers" : {
        self.ee_addr: {
          "finished": False,
          "result": None
        }
      },
    }
    self.chainstore_hset(
      hkey=self.cfg_instance_id,
      key=self.ee_addr,
      value=job_specs
    )
    all_network_jobs = self.chainstore_hgetall(hkey=self.cfg_instance_id)
    report = {}
    for launcher, job in all_network_jobs.items():
      is_current_job = isinstance(job, dict) and job.get("target") == target and launcher == self.ee_addr
      if not is_current_job:
        report[launcher] = job
    #end for
    
    self.P(f"Current jobs:\n{self.json_dumps(all_network_jobs, indent=2)}")
    result = {
      "job_specs": job_specs,
      "worker": self.ee_addr,
      "other_jobs": report,
    }
    return result


  @BasePlugin.endpoint
  def get_job_status(self, target: str):
    """
    Endpoint to retrieve the status or final report of a pentest job for the given target.
    
    TODO: Data must be extracted from CStore
    """
    # If job has completed, return its report
    if target in self.completed_jobs:
      return {
        "target": target,
        "status": "completed",
        "report": self.completed_jobs[target]
      }
    # If job is currently running, return progress info
    job = self.scan_jobs.get(target)
    if job:
      state = job.state
      completed_tests = state.get("completed_tests", [])
      max_features = len(self.__features) + 1 # +1 from port scanning
      progress = f"{(len(completed_tests) / max_features) * 100 if self.__features else 0:.1f}%"
      ports_scanned = state.get("ports_scanned", [])
      open_ports = state.get("open_ports", [])
      return {
        "target": target,
        "status": "in_progress",
        "completed_tests" : state.get("completed_tests", []),
        "progress" : progress,
        "ports_scanned": len(ports_scanned),
        "open_ports": len(open_ports),
        "service_info": state.get("service_info", {}),
        "web_tested": state.get("web_tested", False)
      }
    # Job not found
    return {
      "target": target,
      "status": "not_found",
      "message": "No such job is running or has been completed on this worker."
    }


  def _maybe_launch_jobs(self):
    """
    Launch new PentestJob threads for any announced pentest target.
    Called at each process iteration.
    """
    if self.time() - self.__last_checked_jobs > self.cfg_check_jobs_each:      
      self.__last_checked_jobs = self.time()
      all_jobs = self.chainstore_hgetall(hkey=self.cfg_instance_id)
      for address, job_specs in all_jobs.items():
        if not isinstance(job_specs, dict):
          continue
        target = job_specs.get("target")
        workers = job_specs.get("workers", {})
        current_worker_finished = workers.get(self.ee_addr, {}).get("finished", False)
        if target is None or current_worker_finished:
          continue  
        # If job not already running and not completed, start a new thread
        closed_target = target in self.completed_jobs
        in_progress_target = target in self.scan_jobs
        if not in_progress_target and not closed_target:
          self.P(f"Launching new pentest job requested by {address} for target {target}.")
          job = PentestJobHelper(
            owner=self,
            target=target, 
            worker_target_ports=None, # all ports
          )
          self.scan_jobs[target] = job
          job.start()
        #endif
      #enfor
    #endif
    return


  def _maybe_close_jobs(self):
    for target, job in list(self.scan_jobs.items()):
      # If thread finished or job flagged as done, collect result
      if not job.thread.is_alive() or job.state.get("done"):
        self.P(f"Pentest job for {target} has finished.")
        # Prepare final report for this job
        report = {
          "target": target,
          "open_ports": job.state.get("open_ports", []),
          "service_info_results": job.state.get("service_info", {}),
          "web_test_results": job.state.get("web_test_results", {}) 
        }
        # Save completed report
        self.completed_jobs[target] = report        
        try:
          job_specs = self.chainstore_hget(hkey=self.cfg_instance_id, key=self.ee_addr)
          self.P("Closing job:\n{}\nFor worker {} with report:\n{}".format(
            self.json_dumps(job_specs, indent=2),
            self.ee_addr,
            self.json_dumps(report, indent=2)
          ))
          job_specs["workers"][self.ee_addr]["finished"] = True
          job_specs["workers"][self.ee_addr]["result"] = "Compressed report here"
          self.chainstore_hset(hkey=self.cfg_instance_id, key=self.ee_addr, value=job_specs)
        except Exception as e:
          self.P(f"Error clearing job from chainstore: {e}")
        # Remove from active jobs
        del self.scan_jobs[target]
      #end if
    #end for
    return


  def process(self):
    """
    Periodically invoked to manage job threads.
    Launches new jobs and checks for completed ones.
    """
    super(PentesterApi01Plugin, self).process()
    
    if (self.time() - self.__warmupstart) < self.cfg_warmup_delay:
      # we do not start jobs before API warmup
      return
    elif not self.__warmup_done:
      self.__post_init()
    #endif 
    # Launch any new jobs
    self._maybe_launch_jobs()
    # Check active jobs for completion
    self._maybe_close_jobs()
    return