from naeural_core.business.default.web_app.fast_api_web_app import FastApiWebAppPlugin as BasePlugin
from .pentest_job_helper import PentestJobHelper  # Import PentestJob from separate module

__VER__ = '0.3.1'  # updated version

_CONFIG = {
  **BasePlugin.CONFIG,
  
  'PORT': None,
  
  
  'VALIDATION_RULES': {
    **BasePlugin.CONFIG['VALIDATION_RULES'],  
  },
}

class PentesterApi01Plugin(BasePlugin):
  """
  RedMesh API - a pentesting meta-plugin for receiving pentesting targets and performing operations.
  Supports asynchronous job execution and performs distributed red-team attacks based on 
  decentralized workers orchestrated using CStore.
  """
  CONFIG = _CONFIG


  def on_init(self):
    super(PentesterApi01Plugin, self).on_init()
    self.__features = self._get_all_features()
    # Track active and completed jobs by target
    self.scan_jobs = {}       # target -> PentestJob instance
    self.completed_jobs = {}  # target -> final report dict
    current_epoch = self.netmon.epoch_manager.get_current_epoch()
    self.P(f"Started {self.__class__.__name__} plugin in epoch {current_epoch}.")
    return
  
  
  def _get_all_features(self):
    features = []
    PREFIXES = ["_service_info_", "_web_test_"]
    mock_engine = PentestJobHelper(target='1234', logger=self.P)
    for prefix in PREFIXES:
      methods = [method for method in dir(mock_engine) if method.startswith(prefix)]
      features.extend(methods)
    return features

  @BasePlugin.endpoint
  def list_features(self):
    result = {"features": self.__features}
    return result


  @BasePlugin.endpoint
  def launch_test(self, target : str):
    """
    Endpoint to start a pentest on the specified target.
    Announce job to network via CStore and return current jobs.            
    """
    # INFO: This method only announces the job to the network. It does not 
    #       execute the job itself - that part is handled by PentestJob
    #       executed after periodical check from plugin process.
    self.P(f"Launching pentest on target {target}")
    self.P(f"Announcing pentest to workers (instance_id {self.cfg_instance_id})...")
    self.chainstore_hset(
      hkey=self.cfg_instance_id,
      key=self.ee_addr,
      value=target
    )
    all_network_jobs = self.chainstore_hgetall(hkey=self.cfg_instance_id)
    self.P(f"Current pentest jobs: {self.json_dumps(all_network_jobs, indent=2)}")
    result = {
      "target": target,
      "worker": self.ee_addr,
      "worker_network": all_network_jobs,
    }
    return result


  @BasePlugin.endpoint
  def get_job_status(self, target: str):
    """
    Endpoint to retrieve the status or final report of a pentest job for the given target.
    """
    # If job has completed, return its report
    if target in self.completed_jobs:
      return {
        "target": target,
        "status": "completed",
        "report": self.completed_jobs[target]
      }
    # If job is currently running, return progress info
    job = self.scan_jobs.get(target)
    if job:
      state = job.state
      completed_tests = state.get("completed_tests", [])
      max_features = len(self.__features) + 1 # +1 from port scanning
      progress = f"{(len(completed_tests) / max_features) * 100 if self.__features else 0:.1f}%"
      return {
        "target": target,
        "status": "in_progress",
        "completed_tests" : state.get("completed_tests", []),
        "progress" : progress,
        "ports_scanned": state.get("ports_scanned", []),
        "open_ports": state.get("open_ports", []),
        "service_info": state.get("service_info", {}),
        "web_tested": state.get("web_tested", False)
      }
    # Job not found
    return {
      "target": target,
      "status": "not_found",
      "message": "No such job is running or has been completed on this worker."
    }


  def _maybe_launch_jobs(self):
    """
    Launch new PentestJob threads for any announced pentest target.
    Called at each process iteration.
    """
    all_jobs = self.chainstore_hgetall(hkey=self.cfg_instance_id)
    for address, target in all_jobs.items():
      if target is None:
        continue  # No job announced for this address
      # If job not already running and not completed, start a new thread
      if target not in self.scan_jobs and target not in self.completed_jobs:
        self.P(f"Launching new pentest job requested by {address} for target {target}.")
        job = PentestJobHelper(
          target, 
          logger=self.P,
          worker_target_ports=None,
        )
        self.scan_jobs[target] = job
        job.start()
      #endif
    #enfor
    return


  def _maybe_close_jobs(self):
    for target, job in list(self.scan_jobs.items()):
      # If thread finished or job flagged as done, collect result
      if not job.thread.is_alive() or job.state.get("done"):
        self.P(f"Pentest job for {target} has finished.")
        # Prepare final report for this job
        report = {
          "target": target,
          "open_ports": job.state.get("open_ports", []),
          "service_info": job.state.get("service_info", {}),
        }
        # Save completed report
        self.completed_jobs[target] = report
        # Clear job entry from chainstore to stop other workers
        try:
          self.chainstore_hset(hkey=self.cfg_instance_id, key=self.ee_addr, value=None)
        except Exception as e:
          self.P(f"Error clearing job from chainstore: {e}")
        # Remove from active jobs
        del self.scan_jobs[target]
    return


  def process(self):
    """
    Periodically invoked to manage job threads.
    Launches new jobs and checks for completed ones.
    """
    # Launch any new jobs
    self._maybe_launch_jobs()
    # Check active jobs for completion
    self._maybe_close_jobs()
    return