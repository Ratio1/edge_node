import uuid
import threading
import socket
import ftplib
import requests

from copy import deepcopy

from .service_info_mixin import _ServiceInfoMixin
from .web_tests_mixin import _WebTestsMixin


COMMON_PORTS = [
  21, 22, 23, 25, 53, 80, 110, 143, 443, 445,
  1433, 1521, 3306, 3389, 5900, 8080, 8443, 27017
]

# EXCEPTIONS = [64297]

ALL_PORTS = [port for port in range(1, 65536)]

class PentestJobHelper(
  _ServiceInfoMixin,
  _WebTestsMixin
):
  """
  PentestJob handles the execution of a pentest scanning job for a given target.
  It performs port scanning, service banner gathering, and basic web vulnerability tests.
  
  Parameters
  ----------
  target : str
      The network address (IP or hostname) to scan.
  logger : callable, optional
      Function for logging messages (e.g., plugin.P); if None, prints to stdout.
      
      
  TODO:
    - target ports must be configurable per worker from PENTESTER_API and each worker must receive a slice
  """

  def __init__(
    self, 
    owner, 
    target, 
    job_id : str,
    initiator : str, 
    worker_target_ports=COMMON_PORTS,
    exceptions=[],
  ):
    self.local_worker_id = str(uuid.uuid4())[:4]
    self.owner = owner
    if set(exceptions) & set(worker_target_ports):
      self.P("Some target ports are in the exceptions list, adjusting...")
      self.exceptions = exceptions 
    else:
      self.exceptions = []
    if worker_target_ports is None:
      worker_target_ports = ALL_PORTS
      
    worker_target_ports = [p for p in worker_target_ports if p not in exceptions]
    self.target = target
    self.job_id = job_id
    self.initiator = initiator
    self.initial_ports = list(worker_target_ports)
    # Initialize job state with default scanning parameters

    self.state = {
      "job_id" : self.job_id,
      "initiator" : self.initiator,
      "target": self.target,
      "ports_to_scan": list(worker_target_ports),
      "open_ports": [],
      "ports_scanned": [],
      
      "service_info": {},
      "web_tested": False,
      "web_tests_info": {},
      
      "completed_tests": [],
      "done": False
    }
    self.__features = self._get_all_features()
    self.P("Initialized worker {} on {} ports [{}-{}]...".format(
      self.local_worker_id,
      len(worker_target_ports),
      min(worker_target_ports),
      max(worker_target_ports)
    ))
    return
  
  def _get_all_features(self, categs=False):
    features = {} if categs else []
    PREFIXES = ["_service_info_", "_web_test_"]
    for prefix in PREFIXES:
      methods = [method for method in dir(self) if method.startswith(prefix)]
      if categs:
        features[prefix[1:-1]] = methods
      else:
        features.extend(methods)
    return features  
  
  
  def get_status(self):
    
    completed_tests = self.state.get("completed_tests", [])
    max_features = len(self.__features) + 1 # +1 from port scanning
    progress = f"{(len(completed_tests) / max_features) * 100 if self.__features else 0:.1f}%"
    
    dct_status = {
      "local_worker_id": self.local_worker_id,
      "job_id": self.job_id,
      "initiator": self.initiator,
      "target": self.target,
      
      "ports_range" : [min(self.initial_ports), max(self.initial_ports)],
      "ports_scanned": len(self.state["ports_scanned"]),      
      "nr_open_ports": len(self.state["open_ports"]),
      
      "service_info": self.state["service_info"],
      
      "web_tested": self.state["web_tested"],
      "web_tests_info" : self.state["web_tests_info"],
      
      "completed_tests": self.state["completed_tests"],
      "progress" : progress,
      "done": self.state["done"]
    }
    return dct_status


  def P(self, s, **kwargs):
    s = f"[{self.local_worker_id}:{self.target}] {s}"
    self.owner.P(s, **kwargs)
    return


  def start(self):
    """
    Start the pentest job in a new thread.
    """
    # Event to signal early stopping
    self.stop_event = threading.Event()
    # Thread for running the job
    self.thread = threading.Thread(target=self.execute_job, daemon=True)
    self.thread.start()
    return


  def stop(self):
    """
    Signal the job to stop early.
    """
    self.P(f"Stop requested for job {self.job_id} on worker {self.local_worker_id}")
    self.stop_event.set()
    return


  def execute_job(self):
    """
    Run the full pentesting workflow: port scanning, service info gathering,
    and web vulnerability tests, until the job is complete or stopped.
    """
    self.P(f"Starting pentest job.")
    # Continue running steps until done or stop requested
    while not self.state["done"] and not self.stop_event.is_set():
      # 1. Scan ports in batches if any remain then run tests
      if self.state["ports_to_scan"]:
        # this has to be run in parallel
        self._scan_ports_step()
      #endif 
      # TODO: review and refactor next steps
      # 2. Gather service information for any open ports not yet processed
      unfinished_ports = [
        p for p in self.state["open_ports"]
        if p not in self.state["service_info"]
      ]
      if unfinished_ports:
        self._gather_service_info()
        continue
      # 3. Perform web vulnerability tests if not yet done
      if not self.state["web_tested"]:
        self._run_web_tests()
        continue
      if self.state["ports_to_scan"] == []:
      # 4. All phases done; mark as complete
        self.state["done"] = True
        self.P(f"Job completed. Ports open: {self.state['open_ports']}")
      #end if
    #end while
    # If stopped before completion
    if self.stop_event.is_set():
      self.P(f"Job was stopped before completion.")
    return


  def _scan_ports_step(self, batch_size=None, batch_nr=1):
    """
    Scan a batch of ports from the remaining list to identify open ports.
    """
    target = self.target
    ports = deepcopy(self.state["ports_to_scan"])
    if not ports:
      return
    if batch_size is None:
      ports_batch = ports
    else:
      start_batch = (batch_nr - 1) * batch_size
      ports_batch = ports[start_batch:start_batch + batch_size]
    nr_ports = len(ports_batch)
    self.P(f"Scanning {nr_ports} ports in batch {batch_nr}.")
    for i, port in enumerate(ports_batch):
      if self.stop_event.is_set():
        return
      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      sock.settimeout(0.3)
      try:
        result = sock.connect_ex((target, port))
        if result == 0:
          self.state["open_ports"].append(port)
          self.P(f"Port {port} is open on {target}.")
      except Exception as e:
        self.P(f"Exception scanning port {port} on {target}: {e}")
      finally:
        sock.close()
      # endtry
      self.state["ports_scanned"].append(port)    
      self.state["ports_to_scan"].remove(port)  
      scan_ports_step_progress = (i + 1) / nr_ports * 100
      str_progress = f"{scan_ports_step_progress:.0f}%"
      # now we assume that port scan is first step so we modify 1st stage continously 
      # and we do not append
      self.state["completed_tests"] = [f"scan_ports_step_{str_progress}"]

    left_ports = self.state["ports_to_scan"]
    if not left_ports:
      self.P(f"[{target}] Port scanning completed. {len(self.state['open_ports'])} open ports.")
    else:
      self.P(f"[{target}] Port scanning not completed. Remaining ports: {left_ports}.")
    self.state["completed_tests"].append("scan_ports_step_completed")
    return


  def _gather_service_info(self):
    """
    Gather banner or basic information from each newly open port.
    """
    open_ports = self.state["open_ports"]
    self.P(f"Gathering service info for {len(open_ports)} open ports.")
    target = self.target
    service_info_methods = [method for method in dir(self) if method.startswith("_service_info_")]
    for method in service_info_methods:
      func = getattr(self, method)
      full_info = ""
      for port in open_ports:
        if port in self.state["service_info"] or self.stop_event.is_set():
          continue
        # get all methods that start with _service_info_
        info = func(target, port)
        if info:
          full_info += info
        self.state["service_info"][port] = info
      #end for each port of current method
      # run each method for the current open port
      if full_info:
        self.P(f"Method {method} info: {full_info}")
      self.state["completed_tests"].append(method) # register completed method for port
    # end for each method
    return full_info


  def _run_web_tests(self):
    """
    Perform basic web vulnerability tests if a web service is open.
    """
    open_ports = self.state["open_ports"]
    
    self.P(f"Running web tests on {len(open_ports)} open ports.")
    target = self.target
    
    web_ports = [p for p in open_ports if p in (80, 443, 8080, 8443)]
    if not web_ports:
      self.state["web_tested"] = True
      return
    result = []
    web_tests_methods = [method for method in dir(self) if method.startswith("_web_test_")]
    for method in web_tests_methods:
      func = getattr(self, method)
      for port in web_ports:
        if self.stop_event.is_set():
          return      
        iter_result = func(target, port)
        if iter_result:
          result.append(iter_result)
        self.state["web_tests"][port] = iter_result
      # end for each port of current method
      self.state["completed_tests"].append(method) # register completed method for port    
    # end for each method
    self.state["web_tested"] = True
    return
