
import requests
from urllib.parse import quote

class _WebTestsMixin:
  """
  Mixin class providing web vulnerability testing capabilities.
  """

  def _web_test_common(self, target, port):
    """
    Execute web vulnerability tests against the target.
    
    TODO:
     - encode results for `_run_web_tests` caller
    """
    result = ""
    scheme = "https" if port in (443, 8443) else "http"
    base_url = f"{scheme}://{target}"
    if port not in (80, 443):
      base_url = f"{scheme}://{target}:{port}"
    try:
      # Check common sensitive endpoints
      for path in ["/robots.txt", "/.env", "/.git/", "/admin", "/login"]:
        url = base_url + path
        resp = requests.get(url, timeout=2, verify=False)
        if resp.status_code == 200:
          self.logger(f"[{target}] Accessible resource at {url} (200 OK).")
          result += f"Accessible resource: {url}\n"
        elif resp.status_code in (401, 403):
          self.logger(f"[{target}] Protected resource {url} (status {resp.status_code}).")          
    except Exception as e:
      self.logger(f"[{target}] Web test error on port {port}: {e}")
    return result

  
  def _web_test_homepage(self, target, port):
    """
    Execute web vulnerability tests against the target.
    
    TODO:
     - encode results for `_run_web_tests` caller
    """
    result = ""
    scheme = "https" if port in (443, 8443) else "http"
    base_url = f"{scheme}://{target}"
    if port not in (80, 443):
      base_url = f"{scheme}://{target}:{port}"
    try:
      # Check homepage for leaked info
      resp_main = requests.get(base_url, timeout=3, verify=False)
      text = resp_main.text[:10000]
      for marker in ["API_KEY", "PASSWORD", "SECRET", "BEGIN RSA PRIVATE KEY"]:
        if marker in text:
          result += f"Sensitive marker '{marker}' found on {base_url}.\n"
          self.logger(f"[{target}] Sensitive '{marker}' found on {base_url}.")
      # Check for other potential leaks
      if "database" in text.lower():
        result += f"Potential database leak found on {base_url}.\n"
        self.logger(f"[{target}] Potential database leak found on {base_url}.")
    except Exception as e:
      self.logger(f"[{target}] Web test error on port {port}: {e}")
    return result


  def _web_test_security_headers(self, target, port):
    """
    Check for missing security headers in the response.
    """
    result = ""
    try:
      url = f"http://{target}:{port}"
      resp_main = requests.get(url, timeout=3, verify=False)
      # Check for missing security headers
      security_headers = [
        "Content-Security-Policy",
        "X-Frame-Options",
        "X-Content-Type-Options",
        "Strict-Transport-Security",
        "Referrer-Policy",
      ]
      for header in security_headers:
        if header not in resp_main.headers:
          self.logger(f"[{target}] Missing security header {header} on {url}.")
    except Exception as e:
      self.logger(f"[{target}] Web test error on port {port}: {e}")
    return result


  def _web_test_flags(self, target, port):
    """
    Check for security flags in cookies and other headers.
    """
    result = ""
    scheme = "https" if port in (443, 8443) else "http"
    base_url = f"{scheme}://{target}"
    if port not in (80, 443):
      base_url = f"{scheme}://{target}:{port}"
          
    try:
      url = f"http://{target}:{port}"
      resp_main = requests.get(url, timeout=3, verify=False)
      # Check cookies for Secure/HttpOnly flags
      cookies_hdr = resp_main.headers.get("Set-Cookie", "")
      if cookies_hdr:
        for cookie in cookies_hdr.split(","):
          if "Secure" not in cookie:
            result += f"Cookie missing Secure flag: {cookie.strip()} on {base_url}.\n"
            self.logger(f"[{target}] Cookie missing Secure flag: {cookie.strip()} on {base_url}.")
          if "HttpOnly" not in cookie:
            result += f"Cookie missing HttpOnly flag: {cookie.strip()} on {base_url}.\n"
            self.logger(f"[{target}] Cookie missing HttpOnly flag: {cookie.strip()} on {base_url}.")
      # Detect directory listing
      if "Index of /" in resp_main.text:
        result += f"Directory listing exposed at {base_url}.\n"
        self.logger(f"[{target}] Directory listing exposed at {base_url}.")
    except Exception as e:
      self.logger(f"[{target}] Web test error on port {port}: {e}")
    return result        


  def _web_test_xss(self, target, port):
    """
    Check for Cross-Site Scripting (XSS) vulnerabilities.
    """
    result = ""
    scheme = "https" if port in (443, 8443) else "http"
    base_url = f"{scheme}://{target}"
    if port not in (80, 443):
      base_url = f"{scheme}://{target}:{port}"
    try:
      # Basic XSS reflection test
      payload = "<script>alert(1)</script>"
      test_url = base_url.rstrip("/") + f"/{payload}"
      resp_test = requests.get(test_url, timeout=3, verify=False)
      if payload in resp_test.text:
        self.logger(f"[{target}] VULNERABLE: Reflected XSS at {test_url}.")
        result += f"Reflected XSS vulnerability found at {test_url}.\n"
    except Exception as e:
      self.logger(f"[{target}] Web test error on port {port}: {e}")
    return result     


  def _web_test_path_traversal(self, target, port):
    """
    Check for Path Traversal vulnerabilities.
    """
    result = ""
    scheme = "https" if port in (443, 8443) else "http"
    base_url = f"{scheme}://{target}"
    if port not in (80, 443):
      base_url = f"{scheme}://{target}:{port}"
    try:
      # Path traversal test
      trav_url = base_url.rstrip("/") + "/../../../../etc/passwd"
      resp_trav = requests.get(trav_url, timeout=2, verify=False)
      if "root:x:" in resp_trav.text:
        self.logger(f"[{target}] VULNERABLE: Path traversal at {trav_url}.")
        result += f"Path traversal vulnerability found at {trav_url}.\n"
    except Exception as e:
      self.logger(f"[{target}] Web test error on port {port}: {e}")
    return result     
  
  
  def _web_test_sql_injection(self, target, port):
    """
    Check for SQL Injection vulnerabilities.
    """
    result = ""
    scheme = "https" if port in (443, 8443) else "http"
    base_url = f"{scheme}://{target}"
    if port not in (80, 443):
      base_url = f"{scheme}://{target}:{port}"
    try:
      # Simple SQL injection probe
      inj_payload = quote("1' OR '1'='1")
      inj_url = base_url + f"?id={inj_payload}"
      resp_inj = requests.get(inj_url, timeout=3, verify=False)
      errors = ["sql", "syntax", "mysql", "psql", "postgres", "sqlite", "ora-"]
      body = resp_inj.text.lower()
      if any(err in body for err in errors):
        self.logger(f"[{target}] Potential SQL injection response at {inj_url}.")
        result += f"Potential SQL injection vulnerability found at {inj_url}.\n"
    except Exception as e:
      self.logger(f"[{target}] Web test error on port {port}: {e}")
    return result